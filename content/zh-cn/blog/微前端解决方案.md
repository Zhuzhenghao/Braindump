---
author: 'RuoChen Yao'
title: 微前端解决方案
date: 2023-05-30
description: '微前端的方案对比'
tags: ['微前端', 'qiankun']
thumbnail: https://picsum.photos/id/119/800/400
---

## 1. 背景

现在很多企业，基本在物理上进行了应用代码隔离，实行单个应用单个库，闭环部署更新测试环境、预发布环境和正式环境。于是，我们的探讨的是，基于不同应用**不同库**并**独立部署**的情况下，如何实现多个**应用**之间的**资源共享**？

之前比较多的处理方式是**npm 包形式**抽离和引用，比如多个应用项目之间，可能有某业务逻辑模块或者其他是可复用的，便抽离出来以 npm 包的形式进行管理和使用。但这样却带来了以下几个问题：

- **发布效率低下**。如果需要迭代 npm 包内的逻辑业务，需要先发布 npm 包之后，再每个使用了该 npm 包的应用都更新一次 npm 包版本，再各自构建发布一次，**过程繁琐**。如果涉及到的应用更多的话，花费的人力和精力就更多了。
- **多团队协作容易不规范**。包含通用模块的 npm 包作为共享资产，“每个人”拥有它，但在实践中，这通常意味着没有人拥有它。它很快就会**充满杂乱**的**风格不一致**的代码，没有明确的约定或技术愿景。

![npm方式的繁琐更新流程](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/641a8a9de46b4a04bff6fb11da98a1c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

这些问题让我们意识到，扩展前端开发规模以便于**多个团队**可以**同时开发**一个大型且复杂的产品是一个**重要但又棘手**的**难题**。

因此，早在 2016 年，微前端概念诞生了。

## 微前端介绍

可以由多个团队独立开发的现代 web 应用程序的技术、策略和方案。

![](https://pic3.zhimg.com/v2-5cc5252d02429cf5ccf3cf9b75c4a1f2_r.jpg)

- 微前端**不是一门具体的技术**，而是整合了技术、策略和方法，可能会以脚手架、辅助插件和规范约束这种**生态圈**形式展示出来，是一种宏观上的**架构**。这种架构目前有**多种方案**，都有利弊之处，但只要适用当前业务场景的就是好方案。
- 微前端并**没有技术栈的约束**。每一套微前端方案的设计，都是基于实际需求出发。如果是多团队统一使用了 react 技术栈，可能对微前端方案的跨技术栈使用并没有要求；如果是多团队同时使用了 react 和 vue 技术栈，可能就对微前端的跨技术栈要求比较高。

微前端的核心价值：技术栈无关

![](https://pic1.zhimg.com/v2-2efaa89ac52b38913bdcc0f3603c8e58_b.jpg)

独立开发、独立部署  
微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新

Stitching layer 作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位则仅仅是：导航路由 + 资源加载框架。

![](https://pic1.zhimg.com/v2-49e29d35de9548c02b0d48782714e914_b.jpg)

## 3. 实现方案

## 3.1. 基座方案

single-spa (opens new window)是一个目前主流的微前端采用基座[技术方案](https://www.zhihu.com/search?q=%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22556422347%22%7D)，其主要实现思路：

![](https://pic3.zhimg.com/v2-8975c70fdb273dc3b7013237b48daaba_b.jpg)

内部通信

![](https://pic1.zhimg.com/v2-339cbf4dc83a112396b1d0c2ecd725d0_b.jpg)

预先注册子应用(激活路由、子应用资源、生命周期函数)

监听路由的变化，匹配到了激活的路由则加载子应用资源，顺序调用生命周期函数并最终渲染到容器

![](https://pic2.zhimg.com/v2-8d10e41c6652b346dd69fa90a275e8d1_b.jpg)

在微前端界，**qiankun 算得上是最早成型且知名度最广的框架了，它是真正意义上的单页微前端框架**，那么 qiankun 到底有哪些特点呢，在其官网中我找到了如下概括：

- 基于 single-spa 封装，提供了更加开箱即用的 API
- 技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架
- HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单
- 样式隔离，确保微应用之间样式互相不干扰
- JS 沙箱，确保微应用之间 全局变量/事件 不冲突
- 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度
- umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统 除了最后一点拓展以外，微前端想要达到的效果都已经达到。

## 3.2. iframe 方案

采用 iframe 的方案确实可以做到，而且优点非常明显

优点

- 非常简单，使用没有任何心智负担
- web 应用隔离的非常完美，无论是 js、css、dom 都完全隔离开来
- 由于其隔离的太完美导致缺点也非常明显

缺点

1. url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。
2. UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..
3. 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。
4. 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。

每次打开白屏时间太长，对于 SPA 应用 (opens new window)来说无法接受其中有的问题比较好解决(问题 1)，有的问题我们可以睁一只眼闭一只眼(问题 4)，但有的问题我们则很难解决(问题 3)甚至无法解决(问题 2)，而这些无法解决的问题恰恰又会给产品带来**非常严重的体验问题**。

## 3.3. Web Components

Google 推出的浏览器的原生组件

作为开发者，我们都知道尽可能多的重用代码是一个好主意。这对于自定义标记结构来说通常不是那么容易 — 想想复杂的 HTML（以及相关的样式和脚本），有时您不得不写代码来呈现自定义 UI 控件，并且如果您不小心的话，多次使用它们会使您的页面变得一团糟。

Web Components 旨在解决这些问题 — 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。

它的三项主要技术是指：

- Custom elements（自定义元素）：一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。
- Shadow DOM（影子 DOM）：一组 JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。
- HTML templates（HTML 模板）： <template> 和 <slot> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。

通过以上描述，再结合微前端的概念，我们来看看 Web Components 是如何做到微前端：

1. 技术栈无关：Web Components 是浏览器原生组件，那即是在任何框架中都可以使用。
2. 立开发：使用 Web Components 开发的应用无需与其他应用间产生任何关联。
3. 应用间隔离： Shadow DOM 的特性，各个引入的微应用间可以达到相互隔离的效果。

**综上所述，Web Components 是有能力以组件加载的方式将微应用整合在一起作为微前端的一种手段，但不幸的是，Web Components 是浏览器的新特性，所以它的兼容性不是很好，如果有兼容性要求的项目还是无法使用，具体请查看 can i use。**

## 3.4. EMP

EMP 是由欢聚时代业务中台自主研发的最年轻的**单页微前端解决方案**

**在 qiankun 的模式下，通过中心基座集成各微应用。而在 emp 的方案中不需要中心化的基座，每一个微前端应用都可以通过远程调用的方式引入共享模块。**

![](https://pic3.zhimg.com/v2-679fd7479a012cf31af843330ff24fde_b.jpg)

举一个实际的例子可能更好理解，如下图所示。我们在项目 B 的 Webpack 的 exposes（host） 字段中暴露一个模块叫 Cmp，而在项目 A 的 Webpack 的 remotes 字段中注册远程的模块，然后在使用时，通过 import 完成导入。

![](https://pic2.zhimg.com/v2-436abb0871dfca8557bc64bc5a859dc5_b.jpg)

那么，他有哪些特性呢，下面我们一起看看：

- 基于 Webpack5 的新特性 Module Federation 实现，达到第三方依赖共享，减少不必要的代码引入的目的，什么是 Module Federation 这里就不再赘述。
- 每个微应用独立部署运行，并通过 cdn 的方式引入主程序中，因此只需要部署一次，便可以提供给任何基于 Module Federation 的应用使用。并且此部分代码是远程引入，无需参与应用的打包。
- 动态更新微应用：EMP 是通过 cdn 加载微应用，因此每个微应用中的代码有变动时，无需重新打包发布新的整合应用便能加载到最新的微应用。
- 去中心化，每个微应用间都可以引入其他的微应用，无中心应用的概念。
- 跨技术栈组件式调用，提供了在主应用框架中可以调用其他框架组件的能力（目前已支持互相调用的框架及使用方式请参阅官方文档）。
- 按需加载，开发者可以选择只加载微应用中需要的部分，而不是强制只能将整个应用全部加载。
- 应用间通信，每一个应用都可以进行状态共享，就像在使用 npm 模块进行开发一样便捷。
- 生成对应技术栈模板，它能像 create-react-app 一样，也能像 create-vue-app 一样，通过指令一键搭建好开发环境，减少开发者的负担。
- 远程拉取 ts 声明文件，emp-cli 中内置了拉取远程应用中代码声明文件的能力，让使用 ts 开发的开发者不再为代码报错而烦恼。

**`EMP`除了具备微前端的能力外，还实现了跨应用状态共享、跨框架组件调用的能力，这是现有框架所不具备的优秀特性！**

## 3.5. ESM

ESM 是 ES Module 的缩写，是 Ecma script 2015 中提出的一种前端模块化手段，那么，它又是如何做到微前端的呢？其实，**微前端无外乎三大特性，无技术栈限制、应用单独开发，多应用整合**，只要抓住了这三个特性，那就不难理解 ESM 如何做的了：

1. 无技术栈限制：ESM 加载的只是 js 内容，无论哪个框架，最终都要编译成 js，因此，无论哪种框架，ESM 都能加载。

2. 应用单独开发： ESM 只是 js 的一种规范，不会影响应用的开发模式。

3. 多应用整合： 只要将微应用以 ESM 的方式暴露出来，就能正常加载。

4. 远程加载模块: ESM 能够直接请求 cdn 资源，这是它与生俱来的能力。

ESM 是能做到微前端的核心思想，但是它也存在着兼容性这一大弊端，尽管 ESM 已经很优秀了，但是大部分老版的浏览器仍然无法直接使用，这也是 babel 等编译工具出现的原因，幸运的是，他可以通过 webpack、rollup、esbuild、snowpack 等编译工具成为兼容性的代码。

## 4. 总结

现有微前端解决方案：

- **iframe**
- **Web Components**
- **ESM**
- **qiankun**
- **EMP**

各解决方案的利弊：

- `iframe`可以直接加载其他应用，但无法做到单页导致许多功能无法正常在主应用中展示。
- `web Components`及`ESM`是浏览器提供给开发者的能力，能在单页中实现微前端，不过后者需要做好代码隔离，并且他们都是浏览器的新特性，都存在**兼容性**问题，微前端方面的探索也不成熟，只能作为面向未来的微前端手段。
- `qiankun`基本上可以称为单页版的 iframe，具有**沙箱隔离**及**资源预加载**的特点，几乎无可挑剔。
- `EMP`作为最年轻微前端解决方案，也是吸收了许多 web 优秀特性才诞生的，它在实现微前端的基础上，扩充了**跨应用状态共享**、**跨框架组件调用**、**远程拉取 ts 声明文件**、**动态更新微应用**等能力。同时`EMP`能做到**第三方依赖的共享**，使代码尽可能地重复利用，减少加载的内容。

  以下表格为各解决方案的总结:

| 相对特点            | 相对特点                 | 缺点                                                                                             | 框架               |
| ------------------- | ------------------------ | ------------------------------------------------------------------------------------------------ | ------------------ |
| HTML Entry 接入方式 | HTML Entry 接入方式      |                                                                                                  | single-spa qiankun |
|                     | 资源预加载               |                                                                                                  |                    |
| Module Federation   | 每个微应用独立部署运行   | 目前无法涵盖所有框架                                                                             | EMP                |
|                     | 动态更新微应用           |                                                                                                  |                    |
|                     | 去中心化                 |                                                                                                  |                    |
|                     | 跨技术栈组件式调用       |                                                                                                  |                    |
|                     | 按需加载                 |                                                                                                  |                    |
|                     | 应用间通信               |                                                                                                  |                    |
|                     | 生成对应技术栈模板       |                                                                                                  |                    |
|                     | 远程拉取 ts 声明文件     |                                                                                                  |                    |
| Web Components      | 天生隔离样式与脚本       | 无法兼容所有浏览器                                                                               | Rame               |
| ESM                 | 远程加载模块             | 无法兼容所有浏览器(但可以通过编译工具解决)                                                       |                    |
|                     |                          | 需手动隔离样式（可通过 css module 解决）                                                         |                    |
| iframe              | 天生隔离样式与脚本、多页 | 不是单页应用，会导致浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用                         |                    |
|                     |                          | 弹框类的功能无法应用到整个大应用中，只能在对应的窗口内展示                                       |                    |
|                     |                          | 由于可能应用间不是在相同的域内，主应用的 cookie 要透传到根域名都不同的子应用中才能实现免登录效果 |                    |
|                     |                          | 每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程，占用大量资源的同时也在极大地消耗资源 |                    |
|                     |                          |                                                                                                  |                    |
